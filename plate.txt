    tg::Team::PlayerIterator pi = teamMan.getPlayerBegin(0);
    for (;pi != teamMan.getPlayerEnd(0);pi++){
        switch (pi->state){
        case tg::Player::New:
            break;
        case tg::Player::SendingWhoIs:
            break;
        case tg::Player::WaitingForWhoIsAck:
            break;
        case tg::Player::SendingId:
            break;
        case tg::Player::WaitingForIdAck:
            break;
        case tg::Player::SendingAction:
            break;
        case tg::Player::WaitingForState:
            break;
        case tg::Player::Running:
            break;
        }
    }
-----------------------------------------------------------------------------------------
me:  So, architecture;
there is our beloved main()
 Sent at 6:34 PM on Wednesday
 me:  it basically, creates a Window, and instantiates a Game object
and it pipes all currently pending event notifications from the window, and the network, into the Game object.
 Sent at 6:36 PM on Wednesday
 me:  Now, the thing about a game, or, any program really, is that there are distinct phases in the execution paths, during the life cycle of it..i guess that's over complicating it with words, but the concept is birthed from TankGame's need for a 'Start menu' phase, a 'Lobby' phase, and the 'Actual game' phase.
So, i created the notion of a 'Stage'
and it is illustrated in the code(that i have not pushed) GameStage.h
 Sent at 6:40 PM on Wednesday
 me:  So, the arch-overlord of everything is the TankGame class. it can cycle through the different stages of a game without caring what the stage does. This is done by implementing a stage in a class that inherits from the GameStage class.
TankGame has 3 stages
(i was calling them phase for a sec)
 Sent at 6:43 PM on Wednesday
 me:  they are implemented by the classes 'StartPopup', 'LobbyPopup', 'Game'
that's all i got for now 
 Sent at 6:44 PM on Wednesday
 me:  For networking, I have defined the following Messages:
WhoIs,
       WhoIsAck,
       Id,
       IdAck,
       IdNack,
       Ready,
       Start,
       Action,
       State
 Sent at 7:24 PM on Wednesday
 me:  Ok, so main()
or....ServerMain() and ClientMain()
both are of the same basic structure as the main() you have already studied.
 Sent at 8:00 PM on Wednesday
 me:  The differences between ServerMain and ClientMain are that ServerMain spends most of it's time processing incoming network messages. ClientMain spends most of its time in processing local input, receiving network  data necessary to draw everything, and watching timers
both have the doLoop()
 Sent at 8:03 PM on Wednesday
 me:  doLoop is takes the current state of the game, multiplies it by the current input, and then spits something out that looks like the next state.
it is necessary, because network and local input only execute if there are events to be processed.
where as doLoop, executes every frame
so, doLoop is a good place to watch timers expire so that you can animate, and stuff.
or, in the case of the Server, doLoop will take everything it has recieved from all the players, compute the next state of the game, and transmit that state to each player.
going back to the networking messages i defined..
normal game play will see Action messages spewing out from the players towards the server.
The Action message contains data that indicates either a control action, or an attack action.
So, the Action message is how the client tells the server that it did something.
 Sent at 8:09 PM on Wednesday
 me:  the doLoop will actually be using these incoming Action messages to construct a State message. So the client doesn't do any computation, it is completely dumb. it just draws pretty stufff
i've probably been confusing on when i'm talking about the Server, and when i am talking about the Client.
but, i should be putting this in a document.
-----------------------------------------------------------------------------------------
////////////////WHERE I    AM    ///////////////////////////

#include "Common\Messages.h"
#include "Common\Comm.h"
#include "Common\TeamManager.h"
#include "Common\ArenaManager.h"

#include <iostream>

enum ServerState{
    Establishing,
    Ready,
    Running
};

sf::Clock stateTimer;
ServerState serverState = Establishing;





int doLocalInput(sg::Comm & comm, tg::TeamManager & teamMan)
{
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::T)){
        serverState = Running;
    }
    return 0;
}
int doLoop(sg::Comm & comm, tg::TeamManager & teamMan);
int handleData(sg::Comm & comm, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan, tg::Player & player, sg::CommEvent & event, int cid, int mid);

int main()
{
    bool done = false;
    sg::Comm server;
    tg::TeamManager teamMan;
    tg::ArenaManager arenaMan;

    arenaMan.doInit("Assets\\map1.txt");
    server.StartServer(8280);
    sf::sleep(sf::milliseconds(500));
    while (!done){
        sg::CommEvent event;
        while (server.Receive(event)){
            sf::Uint32 t;
            event.packet >> t;
            switch (t){
                case sg::CommEvent::Acceptance:{
                    sf::Uint32 cid;
                    event.packet >> cid;
                    tg::Player p;
                    p.connectionId = cid;

                    teamMan.addPlayer(p,"New Guy", 0);

                    break;
                }case sg::CommEvent::Disconnect:{
                    sf::Uint32 cid;
                    event.packet >> cid;
                    //remove player from either team0/1/2
                    teamMan.removePlayer(cid);
                    std::cout << "Player " << cid << " Disconnected" << std::endl;
                    break;
                }case sg::CommEvent::Error:
                    break;
                case sg::CommEvent::Data:{
                    sf::Uint32 mid;
                    sf::Uint32 cid;
                    //std::cout << "Got Data" << std::endl;
                    cid = event.connectionId;

                    tg::Player & p = teamMan.getPlayer(cid);

                    event.packet >> mid;
                    handleData(server, teamMan, arenaMan,p,event,cid,mid);
                    break;
                }case sg::CommEvent::Sent:{
                    break;
                }
            }
        }
        doLocalInput(server, teamMan);
        //Do updates to state based on what's happening around us.
        //retransmit State
        doLoop(server, teamMan);

        sf::sleep(sf::milliseconds(30));
    }
    return 0;
}

int handleData(sg::Comm & comm, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan, tg::Player & player, sg::CommEvent & event, int cid, int mid)
{
    switch (mid){
        case tg::Ready:
        {
            std::cout << "Got Ready" << std::endl;
            player.state = Ready;
            //p = teamMan.getPlayer(cid);
            break;
        }
        case tg::WhoIs:
            std::cout << "Got WhoIs" << std::endl;
            sendWhoIsAck(comm, teamMan, cid);
            break;
        case tg::Id:{
                        
            //Received Id msg
            std::string name;
            sf::Uint32 team;
            event.packet >> name;
            event.packet >> team;
            std::cout << "Got Id: " << name << ", " << team << std::endl;
            if (teamMan.isNameValid(name)){
                if (teamMan.isTeamValid(team)){
                    //the specified name and team areok
                    //remove player form limbo
                    teamMan.removePlayer(cid);
                            
                    //add player to requested team
                    player.tank.position = arenaMan.getStartPosition(team);
                    std::cout << "Adding " << name << " to team " << team << std::endl;
                    sf::Uint32 slot = teamMan.addPlayer(player, name, team);

                    //tell player they are established
                    sendIdAck(comm, teamMan, cid, slot);
                }else{
                    sendIdNack(comm, teamMan, cid);
                }
            }else{
                sendIdNack(comm, teamMan, cid);
            }
            break;
        }case tg::Action:{
            std::cout << "Got Action" << std::endl;
            //These are from players when they change the state of the game via an input mechanism
            //After crunching this event, send a Result packet to each player.


            break;
        }
    }
    return 0;
}

int doLoop(sg::Comm & comm, tg::TeamManager & teamMan)
{
    //if (serverstate == Establishing)
    //{
    //}
    //else if (serverstate == Ready)
    //{
    //}
    //else 
    if (serverState == Running)
    {
        //deal with join'ers that are in limbo
        //wait for them to figure out what team they want to be on
        //    if their name is not used, and the team requested is available.
        if (stateTimer.getElapsedTime().asMilliseconds() > 500){
            sendState(comm, teamMan);
            stateTimer.restart();
        }
    }
    return 0;
}

-----------------------------------------------------------------------------------------
////////////////WHERE I WAS GOING///////////////////////////

#include "Common\Messages.h"
#include "Common\Comm.h"
#include "Common\TeamManager.h"
#include "Common\ArenaManager.h"

#include <iostream>

enum ServerState{
    Establishing,
    Ready,
    Running
};

sf::Clock stateTimer;
ServerState serverState = Establishing;


int doLocalInput(sg::Comm & comm, tg::TeamManager & teamMan)
{
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::T)){
        serverState = Running;
    }
    return 0;
}
int doLoop(sg::Comm & comm, tg::TeamManager & teamMan);
int handleData(sg::Comm & comm, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan, tg::Player & player, sg::CommEvent & event, int cid, int mid);
int handleComm(sg::Comm & comm, sg::CommEvent & event, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan);
int handleId(sg::Comm & comm, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan, tg::Player & player, sg::CommEvent & event, int cid, int mid);

int main()
{
    bool done = false;
    sg::Comm server;
    tg::TeamManager teamMan;
    tg::ArenaManager arenaMan;

    arenaMan.doInit("Assets\\map1.txt");
    server.StartServer(8280);
    sf::sleep(sf::milliseconds(500));
    while (!done){
        sg::CommEvent event;
        while (server.Receive(event)){
            sf::Uint32 t;
            event.packet >> t;
            handleComm(server,event,teamMan,arenaMan);
        }
        doLocalInput(server, teamMan);
        //Do updates to state based on what's happening around us.
        //retransmit State
        doLoop(server, teamMan);

        sf::sleep(sf::milliseconds(30));
    }
    return 0;
}


int handleComm(sg::Comm & comm, sg::CommEvent & event, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan)
{
    sf::Uint32 t;
    event.packet >> t;
    switch (t){
        case sg::CommEvent::Acceptance:{
            sf::Uint32 cid;
            tg::Player p;

            event.packet >> cid;
            
            p.connectionId = cid;

            teamMan.addPlayer(p,"New Guy", 0);

            break;
        }case sg::CommEvent::Disconnect:{
            sf::Uint32 cid;
            event.packet >> cid;
            //remove player from either team0/1/2
            teamMan.removePlayer(cid);
            std::cout << "Player " << cid << " Disconnected" << std::endl;
            break;
        }case sg::CommEvent::Error:
            break;
        case sg::CommEvent::Data:{
            sf::Uint32 mid;
            sf::Uint32 cid;
            //std::cout << "Got Data" << std::endl;
            event.packet >> mid;
            cid = event.connectionId;

            tg::Player & p = teamMan.getPlayer(cid);
            
            handleData(comm, teamMan, arenaMan,p,event,cid,mid);
            break;
        }case sg::CommEvent::Sent:{
            break;
        }
    }
    return 0;
}

int handleData(sg::Comm & comm, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan, tg::Player & player, sg::CommEvent & event, int cid, int mid)
{
    switch (mid){
        case tg::Ready:
        {
            std::cout << "Got Ready" << std::endl;
            player.state = Ready;
            //p = teamMan.getPlayer(cid);
            break;
        }
        case tg::WhoIs:
            std::cout << "Got WhoIs" << std::endl;
            sendWhoIsAck(comm, teamMan, cid);
            break;
        case tg::Id:{
            handleId(comm, teamMan, arenaMan,player,event,cid,mid);
            std::cout << "Got Id: " << player.playerName << ", " << player.team << std::endl;
            break;
        }case tg::Action:{
            std::cout << "Got Action" << std::endl;
            //These are from players when they change the state of the game via an input mechanism
            //After crunching this event, send a Result packet to each player.
            break;
        }
    }
    return 0;
}

int handleId(sg::Comm & comm, tg::TeamManager & teamMan, tg::ArenaManager & arenaMan, tg::Player & player, sg::CommEvent & event, int cid, int mid)
{
    //Received Id msg
    std::string name;
    sf::Uint32 team;
    event.packet >> name;
    event.packet >> team;

    if (teamMan.isNameValid(name)){
        if (teamMan.isTeamValid(team)){
            //the specified name and team areok
            //remove player form limbo
            teamMan.removePlayer(cid);
                            
            //add player to requested team
            player.tank.position = arenaMan.getStartPosition(team);
            std::cout << "Adding " << name << " to team " << team << std::endl;
            sf::Uint32 slot = teamMan.addPlayer(player, name, team);

            //tell player they are established
            sendIdAck(comm, teamMan, cid, slot);
        }else{
            sendIdNack(comm, teamMan, cid);
        }
    }else{
        sendIdNack(comm, teamMan, cid);
    }
    return 0;
}

int doLoop(sg::Comm & comm, tg::TeamManager & teamMan)
{
    if (serverState == Running)
    {
        //deal with join'ers that are in limbo
        //wait for them to figure out what team they want to be on
        //    if their name is not used, and the team requested is available.
        if (stateTimer.getElapsedTime().asMilliseconds() > 500){
            sendState(comm, teamMan);
            stateTimer.restart();
        }
    }
    return 0;
}
-----------------------------------------------------------------------------------------

float minDist = 400000000.0f;
            int minIndex=-1;
            int otherTeam = (y==1?2:1);
            sf::Vector2f basePos = g.arenaMan.getStartPosition(y);//.teamMan.teams[y].base1.position
            
            for (auto p = 0;p < g.teamMan.teams[otherTeam].players.size();p++){
                Player & player = g.teamMan.teams[otherTeam].players[p];
                if (player.hasHost == false)
                    continue;
                //Calc distance between base and player
                float dx,dy;
                dx = basePos.x - player.tank.position.x;
                dy = basePos.y - player.tank.position.y;
                float dist = sqrt(dx*dx+dy*dy);
                if (dist < minDist){
                    minDist = dist;
                    minIndex = p;
                }
            }

            if (minIndex != -1)
            {

            }

-----------------------------------------------------------------------------------------
sf::Uint32 StageRun::doDraw(sf::RenderWindow & window, Game & g, sf::Time ft)
{
    if (drawClock.getElapsedTime().asSeconds() > 0.020f)
    {
        window.clear();
        //Set view on top of this player.
        if ((int)g.myTeam != -1){//if == -1, then your team has not yet been established. TODO: i do not like this
            //TODO: move calculations into doLoop
            sf::Vector2f pos = g.teamMan.teams[g.myTeam].players[g.mySlot].tank.position;
            posTrack.push_back(pos);
            if (posTrack.size() > 70)
                posTrack.erase(posTrack.begin());

            pos = sf::Vector2f(0,0);
            for (auto m = 0;m < posTrack.size();m++){
                pos += posTrack[m];
            }
            pos.x  = pos.x / 70.0f;
            pos.y  = pos.y / 70.0f;

            arenaView.reset(sf::FloatRect(pos.x-((g.scrWidth)/2.0f),pos.y-((g.scrHeight)/2.0f),g.scrWidth,g.scrHeight));//sf::FloatRect(0,0,g.scrWidth,g.scrHeight));//
            arenaView.zoom(zoom);
            window.setView(arenaView);
        }
        //Draw the floor tiles
        for (int i = 0;i < g.arenaMan.getMapHorizTileNum()*g.arenaMan.getMapVertTileNum();i++){
            Tile &tile = g.arenaMan.getTile(i);
            sf::Sprite ts;
            ts.setTexture(*g.assetMan.getFloorImage(tile.getName()).tex);
            ts.setPosition(tile.getPosition());
            window.draw(ts);
        }

        sf::Uint32 t1=0;
        sf::Uint32 t2=0;
            for (int t=1;t < 3;t++)
        {
            for (int s = 0;s < g.teamMan.teams[t].players.size();s++)
            {
                Player &p = g.teamMan.teams[t].players[s];
          
                if (p.hasHost && p.tank.health > 0)
                    if (t==1)
                        t1++;
                    else
                        t2++;
            }
            }
        dash.setScore(t1, t2);

        //Draw the tanks
        for (int y=1;y < 3;y++)
        {
            for (int h = 0;h < g.teamMan.teams[y].players.size();h++)
            {
                if (g.teamMan.teams[y].players[h].hasHost)
                {
                    
                    if (g.teamMan.teams[y].players[h].tank.shadowUpdated)
                    {
                        g.teamMan.teams[y].players[h].tank.dx = g.teamMan.teams[y].players[h].tank.shadowPos.x - g.teamMan.teams[y].players[h].tank.position.x;
                        g.teamMan.teams[y].players[h].tank.dy = g.teamMan.teams[y].players[h].tank.shadowPos.y - g.teamMan.teams[y].players[h].tank.position.y;
                        g.teamMan.teams[y].players[h].tank.shadowUpdated = false;
                    }
                    
               
                    //TODO: move calculations into doLoop
                    //store cur location
                    //calculate new position
                    //if new position is closer than previous location, apply
                    //otherwise, do nothing.

                    float ndx,ndy, npx, npy;//New position
                    ndx = g.teamMan.teams[y].players[h].tank.dx;
                    ndy = g.teamMan.teams[y].players[h].tank.dy;
                    npx = g.teamMan.teams[y].players[h].tank.position.x + ndx * ft.asSeconds() * 10.0f;
                    npy = g.teamMan.teams[y].players[h].tank.position.y + ndy * ft.asSeconds() * 10.0f;

                    float cpx,cpy;//Current position
                    cpx = g.teamMan.teams[y].players[h].tank.position.x;
                    cpy = g.teamMan.teams[y].players[h].tank.position.y;

                    float spx,spy;//Shadow position
                    spx = g.teamMan.teams[y].players[h].tank.shadowPos.x;
                    spy = g.teamMan.teams[y].players[h].tank.shadowPos.y;

                    //If mag(dist(n,s)) < mag(dist(c,s))
                    //Then apply.
                    float ndistx, ndisty;
                    float cdistx, cdisty;
                    ndistx = npx - spx;
                    ndisty = npy - spy;
                     
                    cdistx = cpx - spx;
                    cdisty = cpy - spy;

                    float nmag, cmag;
                    cmag = sqrt(cdistx*cdistx+cdisty*cdisty);
                    nmag = sqrt(ndistx*ndistx+ndisty*ndisty);

                    if (nmag <= cmag)
                    {
                        g.teamMan.teams[y].players[h].tank.position.x = npx;
                        g.teamMan.teams[y].players[h].tank.position.y = npy;
                    }else{
                        g.teamMan.teams[y].players[h].tank.position.x = spx;
                        g.teamMan.teams[y].players[h].tank.position.y = spy;
                    }
                    
                

                    std::string tankName;
                    sf::Sprite b,t;
                    //TODO: uh.. i do not like this
                    if (y==1 && h == 0)
                        tankName = "BlueTank";
                    else if (y==1 && h==1)
                        tankName = "RedTank";
                    else if (y==2 && h==0)
                        tankName = "GreenTank";
                    else
                        tankName = "YellowTank";

                    TankImage & ti = g.assetMan.getTankImage(tankName);

                    b.setTexture(*ti.btex);
                    t.setTexture(*ti.ttex);

                    b.setOrigin(40,61);
                    t.setOrigin(27,90);
                
                    b.setRotation(-90);
                    t.setRotation(-90);

                    b.rotate(g.teamMan.teams[y].players[h].tank.bodyAngle);
                    t.rotate(g.teamMan.teams[y].players[h].tank.turretAngle);

               
                    b.setPosition(g.teamMan.teams[y].players[h].tank.position);
                    t.setPosition(g.teamMan.teams[y].players[h].tank.position);

                    for (int k = 0;k < g.teamMan.teams[y].players[h].prjctls.size();k++)
                    {
                        sf::Sprite prjctl;
                        prjctl.setTexture(*g.assetMan.getProjectileImage("Projectile").tex);
                        prjctl.setOrigin(8.0f,8.0f);
                        prjctl.setPosition(g.teamMan.teams[y].players[h].prjctls[k].position);
                        window.draw(prjctl);
                    }

                    window.draw(b);
                    window.draw(t);

                    sf::Text stat;
                    std::stringstream ss;
                    ss << y << "/" << g.teamMan.teams[y].players[h].tank.health << "/" << g.teamMan.teams[y].players[h].tank.power;
                    stat.setString(ss.str());
                    stat.setFont(g.assetMan.getFont());
                    stat.setScale(2.0,2.0);
                    stat.setColor(sf::Color::Green);
                    stat.setPosition(g.teamMan.teams[y].players[h].tank.position.x-75,g.teamMan.teams[y].players[h].tank.position.y-120);
                    window.draw(stat);
                }
            
                //Draw Creep
                for (int lk = 0;lk < g.teamMan.teams[y].creep.size();lk++)
                {
                    sf::Sprite creep;
                    creep.setTexture(*g.assetMan.getMinionImage((y==1 ?"Minion1":"Minion2")).tex);
                    creep.setScale(1.5,1.5);
                    creep.setPosition(g.teamMan.teams[y].creep[lk].position);
                    window.draw(creep);
                }
            
                //Draw Generator lasers
                for (int gi = 0;gi < 2;gi++)
                {
                    for (int k = 0;k < g.teamMan.teams[y].gen[gi].prjctls.size();k++)
                    {
                        sf::Sprite prjctl;
                        prjctl.setTexture(*g.assetMan.getProjectileImage("BaseLaser").tex);
                        prjctl.setOrigin(16.0f,16.0f);
                        prjctl.setPosition(g.teamMan.teams[y].gen[gi].prjctls[k].position);
                        prjctl.setRotation(g.teamMan.teams[y].gen[gi].prjctls[k].angle);
                        window.draw(prjctl);
                    }
                }
                //Draw Base heal ray
                for (int k = 0;k < g.teamMan.teams[y].base1.prjctls.size();k++)
                {
                    sf::Sprite prjctl;
                    prjctl.setTexture(*g.assetMan.getProjectileImage("HealLaser").tex);
                    prjctl.setOrigin(16.0f,16.0f);
                    prjctl.setPosition(g.teamMan.teams[y].base1.prjctls[k].position);
                    prjctl.setRotation(g.teamMan.teams[y].base1.prjctls[k].angle);
                    window.draw(prjctl);
                }
            }
        }

        //Draw the Dashboard
        dashView.reset(sf::FloatRect(0,0, g.scrWidth, g.scrHeight));
   
        window.setView(dashView);
    
        dash.dashPos.x = 0;
        dash.dashPos.y = g.scrHeight-65;//65 is height of dashboard backdrop image.

        dash.backDrop.setTexture(*g.assetMan.getDashboardImage().tex);
        dash.backDrop.setPosition(dash.dashPos);
    
        dash.healthText.setFont(g.assetMan.getFont());
        dash.healthText.setScale(dash.healthTextScale);
        dash.healthText.setPosition(dash.dashPos.x, dash.dashPos.y+8);
    
        dash.speedText.setFont(g.assetMan.getFont());
        dash.speedText.setScale(dash.speedTextScale);
        dash.speedText.setPosition(dash.dashPos.x, dash.dashPos.y+33);

        dash.powerText.setFont(g.assetMan.getFont());
        dash.powerText.setScale(dash.powerTextScale);
        dash.powerText.setPosition(dash.dashPos.x+135, dash.dashPos.y+8);

        dash.scoreText.setFont(g.assetMan.getFont());
        dash.scoreText.setScale(dash.scoreTextScale);
        dash.scoreText.setPosition(dash.dashPos.x+g.scrWidth/2,(dash.dashPos.y-g.scrHeight)+65);

        window.draw(dash.backDrop);
        window.draw(dash.healthText);
        window.draw(dash.speedText);
        window.draw(dash.powerText);
        window.draw(dash.scoreText);

        window.display();

        drawClock.restart();
    }else{
        sf::sleep(sf::seconds(0.0f));
    }
    return 0;
}
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------